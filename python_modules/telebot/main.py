import asyncio
import sqlite3
import subprocess
import os
import time
import logging
from datetime import datetime
from aiogram import Bot, Dispatcher, Router, F, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from dotenv import load_dotenv
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
import psutil
from log_manager import get_latest_log_tail, cleanup_old_logs

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ===
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
load_dotenv(os.path.join(BASE_DIR, ".env"))
API_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
ADMIN_IDS = os.getenv("TELEGRAM_USER_IDS", "").split(",")
DB_PATH = os.path.join(BASE_DIR, "scripts_status.db")

# === –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–æ–≤ ===
SCRIPTS = {}
for item in os.listdir(BASE_DIR):
    if item in ["notification", "price_photo_update", "telebot"]:
        continue
    full_path = os.path.join(BASE_DIR, item, "main.py")
    if os.path.isfile(full_path):
        SCRIPTS[item] = full_path

# === Telegram setup ===
logging.basicConfig(level=logging.INFO)
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# === –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏ —Å—Ç–∞—Ç—É—Å ===
def init_db():
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("""
            CREATE TABLE IF NOT EXISTS script_status (
                name TEXT PRIMARY KEY,
                last_run TEXT,
                success INTEGER,
                duration REAL
            )
        """)
        conn.commit()


def is_script_running(script_path: str) -> bool:
    for proc in psutil.process_iter(['cmdline']):
        try:
            if proc.info['cmdline'] and script_path in " ".join(proc.info['cmdline']):
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    return False


def get_script_runtime(script_path: str) -> float:
    for proc in psutil.process_iter(['create_time', 'cmdline']):
        try:
            if proc.info['cmdline'] and script_path in " ".join(proc.info['cmdline']):
                start_time = datetime.fromtimestamp(proc.info['create_time'])
                return (datetime.now() - start_time).total_seconds()
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    return 0.0


def update_status(name, success, duration):
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("""
            INSERT INTO script_status (name, last_run, success, duration)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(name) DO UPDATE SET
                last_run=excluded.last_run,
                success=excluded.success,
                duration=excluded.duration
        """, (name, datetime.now().isoformat(), int(success), duration))
        conn.commit()


def is_script_running_and_duration(name: str):
    script_path = SCRIPTS.get(name)
    running = False
    for proc in psutil.process_iter(['pid', 'cmdline']):
        try:
            cmdline = " ".join(proc.info['cmdline'])
            if script_path and script_path in cmdline:
                running = True
                break
        except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError):
            continue

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT last_run, duration FROM script_status WHERE name = ?", (name,))
        row = c.fetchone()

    if row:
        last_run_str, last_duration = row
        if running:
            try:
                last_run_dt = datetime.fromisoformat(last_run_str)
                duration = (datetime.now() - last_run_dt).total_seconds()
                return True, duration, last_run_str
            except Exception:
                return True, 0.0, last_run_str
        else:
            return False, last_duration, last_run_str
    return False, 0.0, None


def get_status():
    enriched = []
    for name in SCRIPTS:
        try:
            script_path = SCRIPTS.get(name)
            running = False
            for proc in psutil.process_iter(['cmdline']):
                cmdline = proc.info.get('cmdline') or []
                full_cmd = " ".join(cmdline)
                if full_cmd.endswith(script_path):
                    running = True
                    break

            with sqlite3.connect(DB_PATH) as conn:
                c = conn.cursor()
                c.execute("SELECT last_run, duration FROM script_status WHERE name = ?", (name,))
                row = c.fetchone()

            if row:
                last_run_str, last_duration = row
                if running:
                    try:
                        last_run_dt = datetime.fromisoformat(last_run_str)
                        duration = (datetime.now() - last_run_dt).total_seconds()
                    except Exception:
                        duration = 0.0
                    success = False
                else:
                    duration = last_duration
                    success = True
            else:
                last_run_str = None
                duration = 0.0
                success = not running

            enriched.append((name, last_run_str, success, duration, running))
        except Exception:
            enriched.append((name, None, False, 0.0, False))
    return enriched

# === –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ ===
def get_main_keyboard():
    keyboard = [
        [KeyboardButton(text="üìÇ –°–ª—É–∂–±—ã"), KeyboardButton(text="üìä –°—Ç–∞—Ç—É—Å")],
        [KeyboardButton(text="‚è∞ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ")]
    ]
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def get_script_keyboard(script_name):
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=f"üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å: {script_name}"), KeyboardButton(text=f"üìÑ –õ–æ–≥: {script_name}")],
            [KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )

# === –•–µ–Ω–¥–ª–µ—Ä—ã ===
@router.message(F.text == "/start")
async def show_menu(message: types.Message):
    if str(message.from_user.id) not in ADMIN_IDS:
        return await message.reply("‚õîÔ∏è –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω")
    await message.reply("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_keyboard())


@router.message(F.text == "üìÇ –°–ª—É–∂–±—ã")
async def show_scripts(message: types.Message):
    keyboard = [
        [KeyboardButton(text=name)] for name in sorted(SCRIPTS.keys())
    ]
    keyboard.append([KeyboardButton(text="üîô –ù–∞–∑–∞–¥")])
    await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç:", reply_markup=ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True))


@router.message(F.text == "üìä –°—Ç–∞—Ç—É—Å")
async def show_status(message: types.Message):
    rows = get_status()
    if not rows:
        return await message.reply("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Å—Ç–∞—Ç—É—Å–∞—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤", reply_markup=get_main_keyboard())

    lines = []
    for name, last_run, success, duration, running in rows:
        status = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if running else ("‚úÖ –ó–∞–≤–µ—Ä—à—ë–Ω" if success else "‚ùå –û—à–∏–±–∫–∞")
        duration_text = f"{duration:.2f} —Å–µ–∫." if duration else "‚Äì"
        last_run_fmt = datetime.fromisoformat(last_run).strftime("%Y-%m-%d %H:%M:%S") if last_run else "‚Äì"
        tail = get_latest_log_tail(name) if not success else ""
        block = f"{name}\n–ü–æ—Å–ª–µ–¥–Ω–∏–π –∑–∞–ø—É—Å–∫: {last_run_fmt}\n–°—Ç–∞—Ç—É—Å: {status}\n–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {duration_text}"
        if not success and tail:
            block += f"\n\nüìÑ –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –ª–æ–≥–∞:\n{tail}"
        lines.append(block)

    await message.reply("\n\n".join(lines), reply_markup=get_main_keyboard())


@router.message(F.text == "‚è∞ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def show_schedule_placeholder(message: types.Message):
    await message.reply("‚è≥ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ–∑–∂–µ", reply_markup=get_main_keyboard())


@router.message(F.text == "üîô –ù–∞–∑–∞–¥")
async def go_back(message: types.Message):
    await message.reply("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_keyboard())


@router.message(F.text.in_(SCRIPTS.keys()))
async def show_script_controls(message: types.Message):
    await message.reply(f"–î–µ–π—Å—Ç–≤–∏—è –¥–ª—è {message.text}:", reply_markup=get_script_keyboard(message.text))


@router.message(F.text.startswith("üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å: "))
async def run_script(message: types.Message):
    script_name = message.text.replace("üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å: ", "")
    script_path = SCRIPTS.get(script_name)

    if not script_path or not os.path.isfile(script_path):
        await message.reply(f"‚ùå –°–∫—Ä–∏–ø—Ç {script_name} –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: {script_path}")
        return

    await message.reply(f"‚è≥ –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞: {script_name}\nüß© –ü—É—Ç—å: {script_path}")
    logging.info(f"–ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞ '{script_name}' –ø–æ –ø—É—Ç–∏: {script_path}")
    start_time = time.time()
    try:
        subprocess.Popen(
            ["nohup", "python3", script_path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            preexec_fn=os.setpgrp
        )
        duration = time.time() - start_time
        update_status(script_name, True, duration)
        await message.reply(f"‚úÖ –°–∫—Ä–∏–ø—Ç {script_name} –∑–∞–ø—É—â–µ–Ω", reply_markup=get_script_keyboard(script_name))
    except Exception as e:
        logging.exception(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞ {script_name}")
        update_status(script_name, False, 0)
        await message.reply(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ {script_name}: {str(e)}", reply_markup=get_script_keyboard(script_name))


@router.message(F.text.startswith("üìÑ –õ–æ–≥: "))
async def show_log_tail(message: types.Message):
    script_name = message.text.replace("üìÑ –õ–æ–≥: ", "")
    tail = get_latest_log_tail(script_name)
    reply = f"""üìÑ –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –ª–æ–≥–∞ {script_name}:
{tail}""" if tail else "–õ–æ–≥ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."
    await message.reply(reply, reply_markup=get_script_keyboard(script_name))


# === –§–æ–Ω–æ–≤–∞—è –æ—á–∏—Å—Ç–∫–∞ –ª–æ–≥–æ–≤ ===
def periodic_log_cleanup(interval_seconds=1800):
    async def _loop():
        while True:
            cleanup_old_logs()
            await asyncio.sleep(interval_seconds)
    return _loop()


# === –ó–∞–ø—É—Å–∫ ===
async def main():
    init_db()
    for uid in ADMIN_IDS:
        try:
            await bot.send_message(uid.strip(), "ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω", reply_markup=get_main_keyboard())
        except Exception as e:
            logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ {uid}: {e}")
    asyncio.create_task(periodic_log_cleanup())
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
